#!/bin/bash

# worker script for SSHGrid

# log - echo with host id and timestamp
function log {
	timestamp=`echo -e "\`date\` ($hostnumber/$hostcount)\t"`
	echo "${timestamp}$*"
}

# pop next task from the queuefile
function get_next_task {
	ssh $master "bash -c \"(cd $self; $worker_name remote_getwork )\"" 2>/dev/null
}

# run task
function execute_task {

	task=$*

	log "Executing '$task'"

	process_task
	bash -c "$task" || log "WARNING: Failed with exit code $?"
}

# process task commandline to include more information
function process_task {
	task=$( echo $task | sed -e "s/\$hostnumber/$hostnumber/g" )
}

# identify worker canonically by hostname and pid
function host_id {
	echo -e "`hostname`\t$$\t$hostnumber"
}

# main worker function - run a queuefile
function worker_run {

	worker_name=$2
	master=$3
	hostnumber=$4
	hostcount=$5

	idfile=sshgrid.host_ids

	(
		flock 200
		host_id >> $idfile
	) 200>$idfile.lock

	log "Started worker on `hostname`, PID $$"

	next_task=$(get_next_task)
	while [ $? != "0" ]; do

		# determine what line we encountered
		if [[ ${next_task:0:1} != "#" ]]; then
			# task line, just execute the task
			execute_task $next_task

		elif [[ ${next_task:0:3} == "#%B" ]]; then
			# barrier, wait for other workers
			barrier_wait
		fi

		next_task=$(get_next_task)
	done

	log "Finished."

}

function worker_remote_getwork {

	queuefile=sshgrid.commands.sh
	lockfile=sshgrid.commands.lock

	(
		flock 100

		# get first non-comment line (this can be a barrier, too)
		sed -nre '/^[^#]|(#%B)/{p;q}' $queuefile

		# comment out first non-comment line
		sed -i -re '0,/(^[^#])|(^#%B)/s//#&/' $queuefile

	) 100>$lockfile

}

function get_pid_status {
	hn=$1
	pr=$2
	
	ssh $hn "bash -c 'if [ -d /proc/$pr ]; then echo run; else echo term; fi'" || echo "unknown"
}

function get_log {
	n=$1
	tail -n1 host-$n.log
}

# determine status of worker
function worker_status {
	idfile=sshgrid.host_ids
	
	echo -e "#worker_number\thostname\tpid\tstatus\tlast_log";

	while read -u 100 l; do
		hostname=$(echo $l | cut -d" " -f1)
		pid=$(echo $l | cut -d" " -f2)
		number=$(echo $l | cut -d" " -f3)

		stat=$(get_pid_status $hostname $pid)
		lastlog=$(get_log $number)

		echo -e "$number\t$hostname\t$pid\t$stat\t$lastlog"
	done 100< $idfile | sort
	
}


function send_kill {
	host=$1
	pid=$2
	signal=$3

	ssh $host "bash -c '[ -d /proc/$pid ] && kill $signal $pid && echo Killed $pid on $host with signal $signal'" || echo "could not kill $pid on $host"
}

function worker_kill {
	idfile=sshgrid.host_ids
	signal=$2

	[[ $signal == "" ]] && signal="-SIGKILL"

	( while read -u 100 l; do

		hostname=$(echo $l | cut -d" " -f1)
		pid=$(echo $l | cut -d" " -f2)
		number=$(echo $l | cut -d" " -f3)
		
		stat=$(get_pid_status $hostname $pid)
		
		send_kill $hostname $pid $signal

	done ) 100< $idfile

}


# first argument tells us what we should do
do_what=$1
if [[ $do_what == "run" ]]; then
	worker_run $0 $@
elif [[ $do_what == "status" ]]; then
	worker_status $@
elif [[ $do_what == "kill" ]]; then
	worker_kill $@
elif [[ $do_what == "remote_getwork" ]]; then
	worker_remote_getwork $@
else 
	echo UNKNOWN COMMAND: $do_what >&2
fi


# vim:filetype=sh foldmethod=manual
