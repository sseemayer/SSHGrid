#!/bin/bash

# worker script for SSHGrid

# log - echo with host id and timestamp
function log {
	timestamp=`echo -e "\`date\` ($hostnumber/$hostcount)\t"`
	echo "${timestamp}$*"
}

# pop next task from the queuefile
function get_next_task {
	(
		# get exclusive access to queuefile
		flock 100
		
		linecount=$(wc -l < $queuefile)

		# get first line in queuefile
		task=$(head -n1 $queuefile);
		
		# remove first line, unless special line
		[[ ${task:0:2} == "#%" ]] || sed -i '1d' $queuefile
		
		echo $task

		return $linecount

	) 100>$lockfile
}

# run task
function execute_task {

	task=$*

	log "Executing '$task'"

	process_task
	bash -c "$task" || log "WARNING: Failed with exit code $?"
}

# process task commandline to include more information
function process_task {
	task=$( echo $task | sed -e "s/\$hostnumber/$hostnumber/g" )
}

# identify worker canonically by hostname and pid
function host_id {
	echo -e "`hostname`\t$$\t$hostnumber"
}

# construct a new barrier
function barrier_setup {

	barrier_cycle=$(( ! $barrier_cycle ));
	barrier=$barrier_base.$barrier_cycle

	[ $hostnumber == 0 ] && rm -f $barrier
	
	#log "New barrier file is $barrier"
}

# cleanup a barrier
function barrier_remove {
	(
		# get exclusive access to queuefile
		flock 100

		# get first line in queuefile
		task=$(head -n1 $queuefile);
		
		# delete first barrier line in queuefile
		[[ ${task:0:3} == "#%B" ]] && sed -i '1d' $queuefile
		
		echo $task
		
		rm -f $barrier

	) 100>$lockfile

}

# evaluate barrier waiting condition
function barrier_waiting {

	[ -f $barrier ] || return 1
	waitcount=$( (wc -l < $barrier) 2> /dev/null )
	[[ $waitcount -lt $hostcount ]] || return 2
	return 0

}

# wait on barrier
function barrier_wait {

	log "Encountered $barrier"
	
	# wait until enough hosts queueing
	queuecount=$( (wc -l < $barrier) 2>/dev/null )
	queuecount=$(( $queuecount + 1)) 
	if [[ $queuecount -ge $hostcount ]]; then

		log "Unlocking $barrier"
		barrier_remove

	else 
		log "Waiting on $barrier"

		# queue on the barrier
		host_id >> $barrier
		waiting=0
		while [ $waiting == "0" ]; do
			sleep $barrier_sleeptime
			barrier_waiting
			waiting=$?
		done

	fi

	log "Passed $barrier"

	barrier_setup
}


# main worker function - run a queuefile
function worker_run {

	queuefile=$2
	lockfile=$3
	hostnumber=$4
	hostcount=$5
	idfile=$6

	barrier_base=$lockfile.barrier
	barrier_cycle=1
	barrier_sleeptime=1
	barrier_setup

	(
		flock 200
		host_id >> $idfile
	) 200>$idfile

	log "Started worker on `hostname`, PID $$"

	next_task=$(get_next_task)
	while [ $? != "0" ]; do

		# determine what line we encountered
		if [[ ${next_task:0:1} != "#" ]]; then
			# task line, just execute the task
			execute_task $next_task

		elif [[ ${next_task:0:3} == "#%B" ]]; then
			# barrier, wait for other workers
			barrier_wait
		else
			# comment line, ignore it
			log "Ignored comment $next_task"
		fi

		next_task=$(get_next_task)
	done

	log "Finished."

}


function get_pid_status {
	hn=$1
	pr=$2
	
	ssh $hn "bash -c 'if [ -d /proc/$pr ]; then echo run; else echo term; fi'" || echo "unknown"
}

function get_log {
	n=$1
	tail -n1 host-$n.log
}

# determine status of worker
function worker_status {
	idfile=$2

	
	echo -e "#worker_number\thostname\tpid\tstatus\tlast_log";

	while read -u 100 l; do
		hostname=$(echo $l | cut -d" " -f1)
		pid=$(echo $l | cut -d" " -f2)
		number=$(echo $l | cut -d" " -f3)

		stat=$(get_pid_status $hostname $pid)
		lastlog=$(get_log $number)

		echo -e "$number\t$hostname\t$pid\t$stat\t$lastlog"
	done 100< $idfile | sort
	
}




# first argument tells us what we should do
do_what=$1
if [[ $do_what == "run" ]]; then
	worker_run $@
elif [[ $do_what == "status" ]]; then
	worker_status $@
else 
	echo UNKNOWN COMMAND: $do_what >&2
fi


# vim:filetype=sh foldmethod=manual
